{"instruction": "Explica Algoritmos de cadenas Z-function a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Python, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas z-function.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Comparación de enfoques fuerza bruta vs. optimizado para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Algoritmos de cadenas Z-function para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas z-function.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Recursión, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con recursión.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Dividir y vencer para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Tries (árboles de prefijos), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nMotivación: Se aplica en problemas relacionados con tries (árboles de prefijos).\nProcedimiento:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(L) por operación\nNotas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Programación dinámica subsecuencia común más larga en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Ordenamiento selección para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento selección.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Ordenamiento inserción para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento inserción.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Análisis de complejidad Big-O para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad big-o.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Compara dos enfoques para Análisis de complejidad (Big-O) a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Greedy (cambio de monedas, interval scheduling), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Construye solución paso a paso con la mejor decisión local.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nPasos del algoritmo:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo con traza manual:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(n log n) con ordenamiento\nErrores comunes y buenas prácticas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Depuración de errores debugging para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con depuración de errores debugging.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Pilas y colas de dificultad básico y resuélvelo completamente con ejemplo y código en C++.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pilas y colas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Depuración de errores debugging para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con depuración de errores debugging.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Elige una estructura de datos adecuada para Backtracking (N-Reinas, permutaciones) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Ordenamiento mergesort, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento mergesort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Elige una estructura de datos adecuada para Backtracking permutaciones y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking permutaciones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Grafos BFS para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos bfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Convierte el siguiente pseudocódigo relacionado con Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Técnicas lineales/esperadas para matching de patrones.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nProcedimiento:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: KMP/Z O(n+m); RK promedio O(n+m)\nNotas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Pilas y colas en Go. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pilas y colas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Programación dinámica subsecuencia común más larga. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Ordenamiento mergesort, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento mergesort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Convierte el siguiente pseudocódigo relacionado con Comparación de enfoques (fuerza bruta vs. optimizado) a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques (fuerza bruta vs. optimizado).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Elección de estructura de datos adecuada en C++. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Elige una estructura de datos adecuada para Depuración de errores debugging y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores debugging.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Pseudocódigo a código. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pseudocódigo a código.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Programación dinámica (Fibonacci, mochila, subsecuencia común más larga), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Resuelve subproblemas y almacena resultados para evitar recomputación.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nPasos del algoritmo:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo con traza manual:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Típicamente O(n), O(n^2) según problema\nErrores comunes y buenas prácticas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Elige una estructura de datos adecuada para Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Dividir y vencer en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Árboles balanceados nociones de dificultad avanzado y resuélvelo completamente con ejemplo y código en Python.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados nociones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Convierte el siguiente pseudocódigo relacionado con Caminos mínimos Bellman-Ford a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Convierte el siguiente pseudocódigo relacionado con Caminos mínimos (Dijkstra, Bellman-Ford) a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nPasos del algoritmo:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo con traza manual:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nErrores comunes y buenas prácticas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Árboles balanceados (AVL/Red-Black, nociones) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Ordenamiento inserción, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento inserción.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Compara dos enfoques para Búsqueda binaria a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nMotivación: Se aplica en problemas relacionados con búsqueda binaria.\nProcedimiento:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) tiempo, O(1) espacio\nNotas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Greedy cambio de monedas, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy cambio de monedas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Explica Programación dinámica subsecuencia común más larga a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Convierte el siguiente pseudocódigo relacionado con Programación dinámica mochila a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica mochila.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Elige una estructura de datos adecuada para Caminos mínimos (Dijkstra, Bellman-Ford) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nPasos del algoritmo:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo con traza manual:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nErrores comunes y buenas prácticas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Árboles balanceados AVL/Red-Black, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Árboles balanceados (AVL/Red-Black, nociones). Elige un ejemplo simple y muestra estados intermedios. Usa C si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Backtracking N-Reinas en Java. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking n-reinas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Elección de estructura de datos adecuada. Elige un ejemplo simple y muestra estados intermedios. Usa Python si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Árbol de expansión mínima Kruskal en Java. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Compara dos enfoques para Greedy cambio de monedas a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy cambio de monedas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Tries (árboles de prefijos), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Elige una estructura de datos adecuada para Listas enlazadas y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con listas enlazadas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Programación dinámica Fibonacci en Java. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Programación dinámica Fibonacci. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Ordenamiento selección. Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento selección.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Programación dinámica Fibonacci. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Comparación de enfoques fuerza bruta vs. optimizado, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Grafos DFS. Elige un ejemplo simple y muestra estados intermedios. Usa Java si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos dfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Elección de estructura de datos adecuada de dificultad intermedio y resuélvelo completamente con ejemplo y código en Python.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Árbol de expansión mínima Kruskal para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Ordenamiento burbuja de dificultad avanzado y resuélvelo completamente con ejemplo y código en Go.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento burbuja.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Convierte el siguiente pseudocódigo relacionado con Estructuras de datos avanzadas Heap a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Árbol de expansión mínima (Prim, Kruskal) de dificultad intermedio y resuélvelo completamente con ejemplo y código en Go.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Explica Elección de estructura de datos adecuada a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Explica Grafos DFS a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos dfs.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Elige una estructura de datos adecuada para Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Caminos mínimos (Dijkstra, Bellman-Ford) para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nPasos del algoritmo:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo con traza manual:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nErrores comunes y buenas prácticas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Tries árboles de prefijos en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries árboles de prefijos.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Ordenamiento inserción. Elige un ejemplo simple y muestra estados intermedios. Usa Python si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento inserción.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Algoritmos de cadenas Rabin-Karp para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Explica Ordenamiento selección a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento selección.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Árbol de expansión mínima (Prim, Kruskal) de dificultad intermedio y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Árbol de expansión mínima Prim para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima prim.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Explica Árboles balanceados AVL/Red-Black a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
