{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) en C. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Familia de algoritmos para reordenar elementos según relación de orden.\nMotivación: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nProcedimiento:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nNotas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Ordenamiento inserción, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento inserción.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Árboles balanceados AVL/Red-Black de dificultad básico y resuélvelo completamente con ejemplo y código en Go.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Grafos (BFS, DFS) de dificultad básico y resuélvelo completamente con ejemplo y código en Go.", "response": "Definición/Idea: Recorridos fundamentales para explorar nodos y aristas.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos (bfs, dfs).\nPasos del algoritmo:\n- BFS con cola por niveles\n- DFS con pila o recursión\nEjemplo con traza manual:\nGrafo en línea A-B-C: BFS distancias 0,1,2.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(V+E) tiempo, O(V) espacio\nErrores comunes y buenas prácticas: No marcar visitados al encolar; recursión profunda en DFS\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Análisis de complejidad Big-O para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad big-o.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento mergesort en C. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento mergesort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Árboles balanceados AVL/Red-Black en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Análisis de complejidad (Big-O), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Ordenamiento quicksort de dificultad básico y resuélvelo completamente con ejemplo y código en C++.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento quicksort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Convierte el siguiente pseudocódigo relacionado con Árbol de expansión mínima (Prim, Kruskal) a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Compara dos enfoques para Ordenamiento burbuja a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento burbuja.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Pseudocódigo a código. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Listas enlazadas para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con listas enlazadas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Explica Dividir y vencer a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Go, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Grafos BFS. Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos bfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Explica Pilas y colas a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pilas y colas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Programación dinámica Fibonacci, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Caminos mínimos Bellman-Ford de dificultad avanzado y resuélvelo completamente con ejemplo y código en C++.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Backtracking permutaciones de dificultad básico y resuélvelo completamente con ejemplo y código en Python.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con backtracking permutaciones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Backtracking N-Reinas de dificultad avanzado y resuélvelo completamente con ejemplo y código en C.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking n-reinas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Convierte el siguiente pseudocódigo relacionado con Árboles balanceados AVL/Red-Black a Python y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Convierte el siguiente pseudocódigo relacionado con Programación dinámica mochila a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica mochila.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Compara dos enfoques para Caminos mínimos Bellman-Ford a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Explica Pseudocódigo a código a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Analiza la complejidad temporal y espacial de Algoritmos de cadenas Rabin-Karp para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Árbol de expansión mínima (Prim, Kruskal) en C++. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Guía el diseño paso a paso de un algoritmo para Análisis de complejidad (Big-O), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Elige una estructura de datos adecuada para Algoritmos de cadenas KMP y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas kmp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Corrige y explica errores típicos en un fragmento relacionado con Greedy cambio de monedas en Python. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy cambio de monedas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Realiza una traza paso a paso de Backtracking (N-Reinas, permutaciones). Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Árbol de expansión mínima Prim de dificultad básico y resuélvelo completamente con ejemplo y código en Java.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima prim.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Compara dos enfoques para Programación dinámica subsecuencia común más larga a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Elige una estructura de datos adecuada para Programación dinámica mochila y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica mochila.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"instruction": "Plantea un ejercicio sobre Estructuras de datos avanzadas (Heap, Priority Queue, Deque) de dificultad básico y resuélvelo completamente con ejemplo y código en Python.", "response": "Resumen: Contenedores con operaciones garantizadas eficientes.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nProcedimiento:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) por operación en heap\nNotas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
