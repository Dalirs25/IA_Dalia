{"prompt": "Compara dos enfoques para Programación dinámica Fibonacci a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Depuración de errores debugging a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con depuración de errores debugging.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Búsqueda binaria. Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Resumen: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nMotivación: Se aplica en problemas relacionados con búsqueda binaria.\nProcedimiento:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) tiempo, O(1) espacio\nNotas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Algoritmos de cadenas Z-function a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas z-function.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Ordenamiento burbuja y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento burbuja.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árboles binarios de dificultad avanzado y resuélvelo completamente con ejemplo y código en C.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles binarios.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Comparación de enfoques (fuerza bruta vs. optimizado) de dificultad avanzado y resuélvelo completamente con ejemplo y código en C.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques (fuerza bruta vs. optimizado).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Análisis de complejidad (Big-O) a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Hashing y tablas hash a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Mapea claves a índices con función hash; maneja colisiones.\nMotivación: Se aplica en problemas relacionados con hashing y tablas hash.\nProcedimiento:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Promedio O(1) por operación\nNotas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Análisis de complejidad Big-O a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad big-o.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Backtracking (N-Reinas, permutaciones) a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Programación dinámica (Fibonacci, mochila, subsecuencia común más larga) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Resuelve subproblemas y almacena resultados para evitar recomputación.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nPasos del algoritmo:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo con traza manual:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Típicamente O(n), O(n^2) según problema\nErrores comunes y buenas prácticas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Caminos mínimos (Dijkstra, Bellman-Ford). Elige un ejemplo simple y muestra estados intermedios. Usa Java si aplica.", "response": "Definición/Idea: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nPasos del algoritmo:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo con traza manual:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nErrores comunes y buenas prácticas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) de dificultad avanzado y resuélvelo completamente con ejemplo y código en Go.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Programación dinámica mochila. Elige un ejemplo simple y muestra estados intermedios. Usa C si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica mochila.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Diseño de algoritmos paso a paso en Go. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con diseño de algoritmos paso a paso.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Ordenamiento inserción a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento inserción.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Comparación de enfoques fuerza bruta vs. optimizado a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Análisis de complejidad (Big-O). Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Algoritmos de cadenas Rabin-Karp para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Ordenamiento selección. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento selección.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Depuración de errores (debugging) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con depuración de errores (debugging).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Análisis de complejidad Big-O. Elige un ejemplo simple y muestra estados intermedios. Usa Python si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad big-o.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Árbol de expansión mínima (Prim, Kruskal) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Backtracking permutaciones. Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con backtracking permutaciones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Algoritmos de cadenas Rabin-Karp a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Diseño de algoritmos paso a paso. Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con diseño de algoritmos paso a paso.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Listas enlazadas. Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con listas enlazadas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Algoritmos de cadenas KMP. Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas kmp.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Ordenamiento quicksort a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento quicksort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Tries árboles de prefijos y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con tries árboles de prefijos.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Programación dinámica subsecuencia común más larga a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árboles binarios a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Go, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles binarios.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Grafos BFS a Python y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos bfs.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Greedy cambio de monedas en Go. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy cambio de monedas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Depuración de errores (debugging) en C. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores (debugging).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Tries (árboles de prefijos) a Python y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Búsqueda binaria a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con búsqueda binaria.\nPasos del algoritmo:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo con traza manual:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(log n) tiempo, O(1) espacio\nErrores comunes y buenas prácticas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Análisis de complejidad (Big-O) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Caminos mínimos (Dijkstra, Bellman-Ford), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nPasos del algoritmo:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo con traza manual:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nErrores comunes y buenas prácticas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Tries (árboles de prefijos) a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nMotivación: Se aplica en problemas relacionados con tries (árboles de prefijos).\nProcedimiento:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(L) por operación\nNotas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Análisis de complejidad Big-O en Java. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad big-o.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Grafos (BFS, DFS) de dificultad avanzado y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Resumen: Recorridos fundamentales para explorar nodos y aristas.\nMotivación: Se aplica en problemas relacionados con grafos (bfs, dfs).\nProcedimiento:\n- BFS con cola por niveles\n- DFS con pila o recursión\nEjemplo:\nGrafo en línea A-B-C: BFS distancias 0,1,2.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(V+E) tiempo, O(V) espacio\nNotas: No marcar visitados al encolar; recursión profunda en DFS\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Ordenamiento selección. Elige un ejemplo simple y muestra estados intermedios. Usa C si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento selección.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Depuración de errores debugging en Python. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores debugging.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Técnicas lineales/esperadas para matching de patrones.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nProcedimiento:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: KMP/Z O(n+m); RK promedio O(n+m)\nNotas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Algoritmos de cadenas KMP a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas kmp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Caminos mínimos Bellman-Ford a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Greedy interval scheduling a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy interval scheduling.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Programación dinámica subsecuencia común más larga a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Go, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Estructuras de datos avanzadas Heap para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Greedy (cambio de monedas, interval scheduling). Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Resumen: Construye solución paso a paso con la mejor decisión local.\nMotivación: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nProcedimiento:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(n log n) con ordenamiento\nNotas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Árbol de expansión mínima (Prim, Kruskal) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento quicksort en Java. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento quicksort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Comparación de enfoques (fuerza bruta vs. optimizado) en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques (fuerza bruta vs. optimizado).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Caminos mínimos Dijkstra, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Recursión para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con recursión.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árbol de expansión mínima Kruskal para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árboles balanceados AVL/Red-Black para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Pseudocódigo a código para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Ordenamiento inserción. Elige un ejemplo simple y muestra estados intermedios. Usa Java si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento inserción.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Programación dinámica (Fibonacci, mochila, subsecuencia común más larga) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Resuelve subproblemas y almacena resultados para evitar recomputación.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nPasos del algoritmo:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo con traza manual:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Típicamente O(n), O(n^2) según problema\nErrores comunes y buenas prácticas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Algoritmos de cadenas Z-function de dificultad intermedio y resuélvelo completamente con ejemplo y código en Python.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas z-function.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Greedy (cambio de monedas, interval scheduling) a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Construye solución paso a paso con la mejor decisión local.\nMotivación: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nProcedimiento:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(n log n) con ordenamiento\nNotas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Dividir y vencer de dificultad avanzado y resuélvelo completamente con ejemplo y código en Go.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con dividir y vencer.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Estructuras de datos avanzadas (Heap, Priority Queue, Deque), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Contenedores con operaciones garantizadas eficientes.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nPasos del algoritmo:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo con traza manual:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(log n) por operación en heap\nErrores comunes y buenas prácticas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Estructuras de datos avanzadas (Heap, Priority Queue, Deque). Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Definición/Idea: Contenedores con operaciones garantizadas eficientes.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nPasos del algoritmo:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo con traza manual:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(log n) por operación en heap\nErrores comunes y buenas prácticas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Árboles balanceados nociones a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados nociones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Programación dinámica mochila a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica mochila.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Greedy cambio de monedas. Elige un ejemplo simple y muestra estados intermedios. Usa Python si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy cambio de monedas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árbol de expansión mínima Prim para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima prim.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Depuración de errores debugging para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con depuración de errores debugging.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Elección de estructura de datos adecuada a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árboles balanceados nociones de dificultad básico y resuélvelo completamente con ejemplo y código en C.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados nociones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Tries (árboles de prefijos) de dificultad intermedio y resuélvelo completamente con ejemplo y código en C++.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Programación dinámica subsecuencia común más larga, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Depuración de errores (debugging) en Java. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con depuración de errores (debugging).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Backtracking N-Reinas y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con backtracking n-reinas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Árbol de expansión mínima Prim, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima prim.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Comparación de enfoques fuerza bruta vs. optimizado en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Análisis de complejidad (Big-O) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Algoritmos de cadenas Rabin-Karp, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Tries árboles de prefijos en C++. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries árboles de prefijos.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Árboles balanceados AVL/Red-Black en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Análisis de complejidad Big-O para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad big-o.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Búsqueda binaria de dificultad intermedio y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Resumen: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nMotivación: Se aplica en problemas relacionados con búsqueda binaria.\nProcedimiento:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) tiempo, O(1) espacio\nNotas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Pilas y colas en C++. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pilas y colas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento quicksort para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento quicksort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Greedy cambio de monedas en Java. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy cambio de monedas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Análisis de complejidad Big-O y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad big-o.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Árboles binarios a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles binarios.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Análisis de complejidad Big-O a Python y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad big-o.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Árbol de expansión mínima (Prim, Kruskal) a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Algoritmos de cadenas Rabin-Karp y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Greedy (cambio de monedas, interval scheduling) para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Construye solución paso a paso con la mejor decisión local.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nPasos del algoritmo:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo con traza manual:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(n log n) con ordenamiento\nErrores comunes y buenas prácticas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Recursión, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con recursión.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Caminos mínimos Dijkstra en Java. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Estructuras de datos avanzadas (Heap, Priority Queue, Deque) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Contenedores con operaciones garantizadas eficientes.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nProcedimiento:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) por operación en heap\nNotas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Ordenamiento selección a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento selección.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Greedy interval scheduling para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy interval scheduling.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Ordenamiento mergesort. Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento mergesort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Programación dinámica mochila para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica mochila.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Backtracking permutaciones para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking permutaciones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Comparación de enfoques fuerza bruta vs. optimizado a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Estructuras de datos avanzadas Priority Queue y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas priority queue.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Árboles balanceados (AVL/Red-Black, nociones) en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Programación dinámica (Fibonacci, mochila, subsecuencia común más larga). Elige un ejemplo simple y muestra estados intermedios. Usa Java si aplica.", "response": "Resumen: Resuelve subproblemas y almacena resultados para evitar recomputación.\nMotivación: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nProcedimiento:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Típicamente O(n), O(n^2) según problema\nNotas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Estructuras de datos avanzadas Deque en Java. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas deque.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Árboles balanceados (AVL/Red-Black, nociones) a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento burbuja para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento burbuja.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Estructuras de datos avanzadas Deque a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas deque.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Dividir y vencer, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con dividir y vencer.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Árboles balanceados nociones. Elige un ejemplo simple y muestra estados intermedios. Usa Python si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados nociones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Análisis de complejidad (Big-O) de dificultad básico y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Ordenamiento mergesort. Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento mergesort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Estructuras de datos avanzadas Deque para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas deque.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Comparación de enfoques fuerza bruta vs. optimizado en C++. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) de dificultad básico y resuélvelo completamente con ejemplo y código en C.", "response": "Definición/Idea: Técnicas lineales/esperadas para matching de patrones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nPasos del algoritmo:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo con traza manual:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: KMP/Z O(n+m); RK promedio O(n+m)\nErrores comunes y buenas prácticas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Programación dinámica subsecuencia común más larga a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Caminos mínimos (Dijkstra, Bellman-Ford) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nMotivación: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nProcedimiento:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nNotas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Greedy cambio de monedas a Python y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy cambio de monedas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Programación dinámica subsecuencia común más larga a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Pilas y colas de dificultad intermedio y resuélvelo completamente con ejemplo y código en C++.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pilas y colas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento burbuja, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento burbuja.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Caminos mínimos Dijkstra de dificultad avanzado y resuélvelo completamente con ejemplo y código en Java.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Caminos mínimos (Dijkstra, Bellman-Ford) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nMotivación: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nProcedimiento:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nNotas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Programación dinámica Fibonacci, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica fibonacci.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árboles binarios para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles binarios.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento mergesort en C++. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento mergesort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Backtracking (N-Reinas, permutaciones) a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Depuración de errores (debugging) a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con depuración de errores (debugging).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Backtracking (N-Reinas, permutaciones) a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Pilas y colas, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pilas y colas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Estructuras de datos avanzadas Priority Queue a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas priority queue.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Árboles binarios y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles binarios.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Ordenamiento mergesort a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento mergesort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Estructuras de datos avanzadas Priority Queue y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas priority queue.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Hashing y tablas hash, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Mapea claves a índices con función hash; maneja colisiones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con hashing y tablas hash.\nPasos del algoritmo:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo con traza manual:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Promedio O(1) por operación\nErrores comunes y buenas prácticas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Técnicas lineales/esperadas para matching de patrones.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nProcedimiento:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: KMP/Z O(n+m); RK promedio O(n+m)\nNotas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Árboles binarios y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles binarios.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Algoritmos de cadenas KMP y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas kmp.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Listas enlazadas a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con listas enlazadas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Pseudocódigo a código a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pseudocódigo a código.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Árboles balanceados nociones. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados nociones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Árbol de expansión mínima Prim, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima prim.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) a JavaScript y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Técnicas lineales/esperadas para matching de patrones.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nProcedimiento:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: KMP/Z O(n+m); RK promedio O(n+m)\nNotas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Árbol de expansión mínima (Prim, Kruskal) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Listas enlazadas en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con listas enlazadas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Greedy cambio de monedas, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy cambio de monedas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Estructuras de datos avanzadas Heap. Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Greedy (cambio de monedas, interval scheduling) de dificultad avanzado y resuélvelo completamente con ejemplo y código en C++.", "response": "Definición/Idea: Construye solución paso a paso con la mejor decisión local.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nPasos del algoritmo:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo con traza manual:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(n log n) con ordenamiento\nErrores comunes y buenas prácticas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Ordenamiento selección a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento selección.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Recursión a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con recursión.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Hashing y tablas hash a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Python, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Mapea claves a índices con función hash; maneja colisiones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con hashing y tablas hash.\nPasos del algoritmo:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo con traza manual:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Promedio O(1) por operación\nErrores comunes y buenas prácticas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Estructuras de datos avanzadas Heap, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Ordenamiento inserción. Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento inserción.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento mergesort para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento mergesort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Greedy interval scheduling a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy interval scheduling.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Grafos BFS y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos bfs.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Familia de algoritmos para reordenar elementos según relación de orden.\nMotivación: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nProcedimiento:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nNotas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Algoritmos de cadenas Z-function a JavaScript y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas z-function.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Grafos (BFS, DFS), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Recorridos fundamentales para explorar nodos y aristas.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos (bfs, dfs).\nPasos del algoritmo:\n- BFS con cola por niveles\n- DFS con pila o recursión\nEjemplo con traza manual:\nGrafo en línea A-B-C: BFS distancias 0,1,2.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(V+E) tiempo, O(V) espacio\nErrores comunes y buenas prácticas: No marcar visitados al encolar; recursión profunda en DFS\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Backtracking (N-Reinas, permutaciones) de dificultad avanzado y resuélvelo completamente con ejemplo y código en C.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Programación dinámica Fibonacci a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica fibonacci.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Comparación de enfoques fuerza bruta vs. optimizado y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Algoritmos de cadenas Z-function a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Python, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas z-function.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento quicksort en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento quicksort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Ordenamiento mergesort a JavaScript y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento mergesort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Análisis de complejidad (Big-O) a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento mergesort para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento mergesort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Tries (árboles de prefijos), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Tries árboles de prefijos a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries árboles de prefijos.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Árboles binarios. Elige un ejemplo simple y muestra estados intermedios. Usa C si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles binarios.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento selección en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento selección.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Hashing y tablas hash. Elige un ejemplo simple y muestra estados intermedios. Usa Java si aplica.", "response": "Resumen: Mapea claves a índices con función hash; maneja colisiones.\nMotivación: Se aplica en problemas relacionados con hashing y tablas hash.\nProcedimiento:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Promedio O(1) por operación\nNotas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Algoritmos de cadenas Rabin-Karp a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Depuración de errores (debugging) a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores (debugging).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Árbol de expansión mínima (Prim, Kruskal) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Tries (árboles de prefijos) a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nMotivación: Se aplica en problemas relacionados con tries (árboles de prefijos).\nProcedimiento:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(L) por operación\nNotas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento selección en Python. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento selección.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Tries árboles de prefijos en Java. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con tries árboles de prefijos.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Backtracking permutaciones de dificultad avanzado y resuélvelo completamente con ejemplo y código en C.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con backtracking permutaciones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Greedy interval scheduling y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy interval scheduling.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árboles binarios a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles binarios.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Grafos DFS a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos dfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Ordenamiento burbuja. Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento burbuja.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Búsqueda binaria a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Go, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con búsqueda binaria.\nPasos del algoritmo:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo con traza manual:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(log n) tiempo, O(1) espacio\nErrores comunes y buenas prácticas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Estructuras de datos avanzadas Deque. Elige un ejemplo simple y muestra estados intermedios. Usa Java si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas deque.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Estructuras de datos avanzadas Heap, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Estructuras de datos avanzadas Heap a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Hashing y tablas hash de dificultad intermedio y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Definición/Idea: Mapea claves a índices con función hash; maneja colisiones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con hashing y tablas hash.\nPasos del algoritmo:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo con traza manual:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Promedio O(1) por operación\nErrores comunes y buenas prácticas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Grafos (BFS, DFS) a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Recorridos fundamentales para explorar nodos y aristas.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos (bfs, dfs).\nPasos del algoritmo:\n- BFS con cola por niveles\n- DFS con pila o recursión\nEjemplo con traza manual:\nGrafo en línea A-B-C: BFS distancias 0,1,2.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(V+E) tiempo, O(V) espacio\nErrores comunes y buenas prácticas: No marcar visitados al encolar; recursión profunda en DFS\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Listas enlazadas. Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con listas enlazadas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Dividir y vencer a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con dividir y vencer.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Algoritmos de cadenas Rabin-Karp a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Ordenamiento inserción a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento inserción.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Recursión y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con recursión.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Tries (árboles de prefijos) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Programación dinámica (Fibonacci, mochila, subsecuencia común más larga), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Resuelve subproblemas y almacena resultados para evitar recomputación.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nPasos del algoritmo:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo con traza manual:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Típicamente O(n), O(n^2) según problema\nErrores comunes y buenas prácticas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Backtracking permutaciones a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking permutaciones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Análisis de complejidad (Big-O) a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Técnicas lineales/esperadas para matching de patrones.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nProcedimiento:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: KMP/Z O(n+m); RK promedio O(n+m)\nNotas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Árboles balanceados (AVL/Red-Black, nociones) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Backtracking permutaciones para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking permutaciones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Ordenamiento burbuja a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento burbuja.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Backtracking permutaciones a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Python, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking permutaciones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Árbol de expansión mínima (Prim, Kruskal) a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Búsqueda binaria de dificultad intermedio y resuélvelo completamente con ejemplo y código en Java.", "response": "Resumen: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nMotivación: Se aplica en problemas relacionados con búsqueda binaria.\nProcedimiento:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) tiempo, O(1) espacio\nNotas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Greedy (cambio de monedas, interval scheduling) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Construye solución paso a paso con la mejor decisión local.\nMotivación: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nProcedimiento:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(n log n) con ordenamiento\nNotas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Grafos BFS a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos bfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Greedy cambio de monedas a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy cambio de monedas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Tries árboles de prefijos. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries árboles de prefijos.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Estructuras de datos avanzadas (Heap, Priority Queue, Deque) de dificultad básico y resuélvelo completamente con ejemplo y código en C.", "response": "Resumen: Contenedores con operaciones garantizadas eficientes.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nProcedimiento:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) por operación en heap\nNotas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Comparación de enfoques (fuerza bruta vs. optimizado) a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques (fuerza bruta vs. optimizado).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Programación dinámica subsecuencia común más larga a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árbol de expansión mínima (Prim, Kruskal) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento selección, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento selección.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Pseudocódigo a código a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Tries (árboles de prefijos) para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nMotivación: Se aplica en problemas relacionados con tries (árboles de prefijos).\nProcedimiento:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(L) por operación\nNotas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Elección de estructura de datos adecuada en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Recursión en Python. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con recursión.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Backtracking permutaciones y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking permutaciones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Grafos DFS, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos dfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Análisis de complejidad (Big-O) a Python y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Familia de algoritmos para reordenar elementos según relación de orden.\nMotivación: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nProcedimiento:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nNotas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Greedy (cambio de monedas, interval scheduling) de dificultad avanzado y resuélvelo completamente con ejemplo y código en Python.", "response": "Resumen: Construye solución paso a paso con la mejor decisión local.\nMotivación: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nProcedimiento:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(n log n) con ordenamiento\nNotas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Hashing y tablas hash para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Mapea claves a índices con función hash; maneja colisiones.\nMotivación: Se aplica en problemas relacionados con hashing y tablas hash.\nProcedimiento:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Promedio O(1) por operación\nNotas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Comparación de enfoques (fuerza bruta vs. optimizado) en Java. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques (fuerza bruta vs. optimizado).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento inserción, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento inserción.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento inserción para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento inserción.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Análisis de complejidad (Big-O) a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Estructuras de datos avanzadas Heap y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Ordenamiento burbuja y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento burbuja.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Hashing y tablas hash en C. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Mapea claves a índices con función hash; maneja colisiones.\nMotivación: Se aplica en problemas relacionados con hashing y tablas hash.\nProcedimiento:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Promedio O(1) por operación\nNotas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Backtracking permutaciones a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con backtracking permutaciones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Estructuras de datos avanzadas (Heap, Priority Queue, Deque) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Contenedores con operaciones garantizadas eficientes.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nProcedimiento:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) por operación en heap\nNotas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Tries (árboles de prefijos) a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Python, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nMotivación: Se aplica en problemas relacionados con tries (árboles de prefijos).\nProcedimiento:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(L) por operación\nNotas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) de dificultad intermedio y resuélvelo completamente con ejemplo y código en Python.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árboles balanceados AVL/Red-Black a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Go, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Algoritmos de cadenas Rabin-Karp, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Greedy (cambio de monedas, interval scheduling), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Construye solución paso a paso con la mejor decisión local.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nPasos del algoritmo:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo con traza manual:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(n log n) con ordenamiento\nErrores comunes y buenas prácticas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Elección de estructura de datos adecuada en Go. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Tries (árboles de prefijos) en C++. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Árbol de expansión mínima (Prim, Kruskal). Elige un ejemplo simple y muestra estados intermedios. Usa Python si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Programación dinámica Fibonacci. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árboles balanceados AVL/Red-Black para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Diseño de algoritmos paso a paso, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con diseño de algoritmos paso a paso.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Estructuras de datos avanzadas Priority Queue de dificultad básico y resuélvelo completamente con ejemplo y código en Python.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas priority queue.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Programación dinámica (Fibonacci, mochila, subsecuencia común más larga) de dificultad básico y resuélvelo completamente con ejemplo y código en C.", "response": "Definición/Idea: Resuelve subproblemas y almacena resultados para evitar recomputación.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nPasos del algoritmo:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo con traza manual:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Típicamente O(n), O(n^2) según problema\nErrores comunes y buenas prácticas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Caminos mínimos Dijkstra a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Caminos mínimos Dijkstra de dificultad intermedio y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árboles balanceados (AVL/Red-Black, nociones) a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Greedy interval scheduling a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy interval scheduling.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Grafos DFS para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos dfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Diseño de algoritmos paso a paso, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con diseño de algoritmos paso a paso.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Ordenamiento burbuja de dificultad avanzado y resuélvelo completamente con ejemplo y código en Go.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento burbuja.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Árboles balanceados nociones a JavaScript y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados nociones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento selección para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento selección.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Recursión de dificultad intermedio y resuélvelo completamente con ejemplo y código en C.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con recursión.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Elección de estructura de datos adecuada a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Backtracking (N-Reinas, permutaciones) en C. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Análisis de complejidad (Big-O). Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Grafos DFS a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos dfs.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Comparación de enfoques (fuerza bruta vs. optimizado) en Python. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques (fuerza bruta vs. optimizado).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Análisis de complejidad Big-O, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad big-o.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árbol de expansión mínima Kruskal de dificultad avanzado y resuélvelo completamente con ejemplo y código en C.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Hashing y tablas hash y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Mapea claves a índices con función hash; maneja colisiones.\nMotivación: Se aplica en problemas relacionados con hashing y tablas hash.\nProcedimiento:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Promedio O(1) por operación\nNotas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Tries árboles de prefijos y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries árboles de prefijos.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento burbuja, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento burbuja.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Pilas y colas para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pilas y colas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Árbol de expansión mínima Prim, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima prim.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Tries (árboles de prefijos) a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Algoritmos de cadenas Z-function a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas z-function.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Depuración de errores debugging, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con depuración de errores debugging.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Tries árboles de prefijos en C++. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con tries árboles de prefijos.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Ordenamiento inserción a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento inserción.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Backtracking N-Reinas para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking n-reinas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Tries árboles de prefijos a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con tries árboles de prefijos.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Ordenamiento burbuja a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento burbuja.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Diseño de algoritmos paso a paso a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con diseño de algoritmos paso a paso.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Depuración de errores (debugging) a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Python, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores (debugging).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Grafos DFS y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos dfs.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Listas enlazadas para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con listas enlazadas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Pseudocódigo a código de dificultad intermedio y resuélvelo completamente con ejemplo y código en C.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Comparación de enfoques (fuerza bruta vs. optimizado) a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques (fuerza bruta vs. optimizado).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Comparación de enfoques fuerza bruta vs. optimizado en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Greedy (cambio de monedas, interval scheduling) en C++. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Construye solución paso a paso con la mejor decisión local.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nPasos del algoritmo:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo con traza manual:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(n log n) con ordenamiento\nErrores comunes y buenas prácticas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Algoritmos de cadenas Rabin-Karp en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Estructuras de datos avanzadas (Heap, Priority Queue, Deque) a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Contenedores con operaciones garantizadas eficientes.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nProcedimiento:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) por operación en heap\nNotas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Programación dinámica subsecuencia común más larga en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Grafos DFS a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos dfs.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Algoritmos de cadenas Z-function en Go. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas z-function.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Depuración de errores (debugging) a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores (debugging).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Tries árboles de prefijos. Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries árboles de prefijos.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Programación dinámica Fibonacci a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica fibonacci.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Caminos mínimos Dijkstra y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árboles balanceados (AVL/Red-Black, nociones) de dificultad intermedio y resuélvelo completamente con ejemplo y código en C++.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Ordenamiento mergesort a JavaScript y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento mergesort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Grafos DFS en Go. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos dfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Grafos BFS a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos bfs.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento inserción para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento inserción.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Árboles balanceados (AVL/Red-Black, nociones) a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Árboles binarios, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles binarios.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Árboles balanceados (AVL/Red-Black, nociones) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Diseño de algoritmos paso a paso y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con diseño de algoritmos paso a paso.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Pilas y colas de dificultad básico y resuélvelo completamente con ejemplo y código en C++.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pilas y colas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Tries árboles de prefijos a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con tries árboles de prefijos.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árbol de expansión mínima (Prim, Kruskal) para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Caminos mínimos Bellman-Ford a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Tries (árboles de prefijos) para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento mergesort en Java. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento mergesort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Backtracking N-Reinas y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking n-reinas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Análisis de complejidad Big-O de dificultad intermedio y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad big-o.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Ordenamiento inserción a Python y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento inserción.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Programación dinámica (Fibonacci, mochila, subsecuencia común más larga) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Resuelve subproblemas y almacena resultados para evitar recomputación.\nMotivación: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nProcedimiento:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Típicamente O(n), O(n^2) según problema\nNotas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Estructuras de datos avanzadas (Heap, Priority Queue, Deque) a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Contenedores con operaciones garantizadas eficientes.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nPasos del algoritmo:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo con traza manual:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(log n) por operación en heap\nErrores comunes y buenas prácticas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Depuración de errores debugging de dificultad intermedio y resuélvelo completamente con ejemplo y código en Java.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores debugging.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Árboles balanceados nociones a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados nociones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Greedy (cambio de monedas, interval scheduling) en Go. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Construye solución paso a paso con la mejor decisión local.\nMotivación: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nProcedimiento:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(n log n) con ordenamiento\nNotas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árboles balanceados nociones para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados nociones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento quicksort, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento quicksort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Greedy (cambio de monedas, interval scheduling) de dificultad básico y resuélvelo completamente con ejemplo y código en C.", "response": "Definición/Idea: Construye solución paso a paso con la mejor decisión local.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nPasos del algoritmo:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo con traza manual:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(n log n) con ordenamiento\nErrores comunes y buenas prácticas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Análisis de complejidad Big-O a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad big-o.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Ordenamiento burbuja a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento burbuja.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Ordenamiento mergesort a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento mergesort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Backtracking permutaciones a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking permutaciones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Algoritmos de cadenas Rabin-Karp a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Estructuras de datos avanzadas Deque a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas deque.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Ordenamiento quicksort a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento quicksort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Greedy cambio de monedas, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy cambio de monedas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Tries árboles de prefijos a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con tries árboles de prefijos.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Búsqueda binaria a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con búsqueda binaria.\nPasos del algoritmo:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo con traza manual:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(log n) tiempo, O(1) espacio\nErrores comunes y buenas prácticas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Búsqueda binaria a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nMotivación: Se aplica en problemas relacionados con búsqueda binaria.\nProcedimiento:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) tiempo, O(1) espacio\nNotas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Ordenamiento burbuja a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento burbuja.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Greedy cambio de monedas en C++. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy cambio de monedas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Comparación de enfoques fuerza bruta vs. optimizado a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Python, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Pseudocódigo a código en C++. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árboles balanceados (AVL/Red-Black, nociones) de dificultad intermedio y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Programación dinámica Fibonacci, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Programación dinámica (Fibonacci, mochila, subsecuencia común más larga) de dificultad básico y resuélvelo completamente con ejemplo y código en Java.", "response": "Definición/Idea: Resuelve subproblemas y almacena resultados para evitar recomputación.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nPasos del algoritmo:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo con traza manual:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Típicamente O(n), O(n^2) según problema\nErrores comunes y buenas prácticas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Dividir y vencer a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con dividir y vencer.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Pilas y colas. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pilas y colas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) de dificultad básico y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Algoritmos de cadenas Rabin-Karp para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento burbuja, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento burbuja.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Elección de estructura de datos adecuada a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Estructuras de datos avanzadas Heap a Python y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Análisis de complejidad Big-O y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad big-o.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Caminos mínimos (Dijkstra, Bellman-Ford) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nMotivación: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nProcedimiento:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nNotas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento selección en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento selección.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Programación dinámica mochila y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica mochila.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Dividir y vencer, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Comparación de enfoques fuerza bruta vs. optimizado a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Programación dinámica subsecuencia común más larga, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Caminos mínimos Dijkstra en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árbol de expansión mínima Kruskal a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Hashing y tablas hash a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Mapea claves a índices con función hash; maneja colisiones.\nMotivación: Se aplica en problemas relacionados con hashing y tablas hash.\nProcedimiento:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Promedio O(1) por operación\nNotas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Greedy (cambio de monedas, interval scheduling) a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Construye solución paso a paso con la mejor decisión local.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nPasos del algoritmo:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo con traza manual:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(n log n) con ordenamiento\nErrores comunes y buenas prácticas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Tries (árboles de prefijos). Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Caminos mínimos Dijkstra y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Programación dinámica mochila y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica mochila.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Caminos mínimos Dijkstra en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Búsqueda binaria y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con búsqueda binaria.\nPasos del algoritmo:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo con traza manual:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(log n) tiempo, O(1) espacio\nErrores comunes y buenas prácticas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Recursión para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con recursión.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Tries árboles de prefijos y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries árboles de prefijos.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) en Go. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Técnicas lineales/esperadas para matching de patrones.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nProcedimiento:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: KMP/Z O(n+m); RK promedio O(n+m)\nNotas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Tries (árboles de prefijos). Elige un ejemplo simple y muestra estados intermedios. Usa C si aplica.", "response": "Resumen: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nMotivación: Se aplica en problemas relacionados con tries (árboles de prefijos).\nProcedimiento:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(L) por operación\nNotas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Hashing y tablas hash, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Mapea claves a índices con función hash; maneja colisiones.\nMotivación: Se aplica en problemas relacionados con hashing y tablas hash.\nProcedimiento:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Promedio O(1) por operación\nNotas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Árbol de expansión mínima (Prim, Kruskal). Elige un ejemplo simple y muestra estados intermedios. Usa Python si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Pseudocódigo a código. Elige un ejemplo simple y muestra estados intermedios. Usa Java si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pseudocódigo a código.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Búsqueda binaria en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con búsqueda binaria.\nPasos del algoritmo:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo con traza manual:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(log n) tiempo, O(1) espacio\nErrores comunes y buenas prácticas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Pseudocódigo a código. Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pseudocódigo a código.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Recursión. Elige un ejemplo simple y muestra estados intermedios. Usa Go si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con recursión.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Grafos DFS en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos dfs.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Estructuras de datos avanzadas Heap para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Backtracking N-Reinas para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking n-reinas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Diseño de algoritmos paso a paso a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con diseño de algoritmos paso a paso.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Ordenamiento selección a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento selección.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Greedy interval scheduling, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy interval scheduling.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Técnicas lineales/esperadas para matching de patrones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nPasos del algoritmo:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo con traza manual:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: KMP/Z O(n+m); RK promedio O(n+m)\nErrores comunes y buenas prácticas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento quicksort, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento quicksort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árboles balanceados (AVL/Red-Black, nociones) de dificultad básico y resuélvelo completamente con ejemplo y código en Go.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Pseudocódigo a código, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Grafos DFS de dificultad básico y resuélvelo completamente con ejemplo y código en C++.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos dfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Caminos mínimos Dijkstra de dificultad básico y resuélvelo completamente con ejemplo y código en C++.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Grafos DFS en C++. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos dfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Programación dinámica (Fibonacci, mochila, subsecuencia común más larga), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Resuelve subproblemas y almacena resultados para evitar recomputación.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nPasos del algoritmo:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo con traza manual:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Típicamente O(n), O(n^2) según problema\nErrores comunes y buenas prácticas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Programación dinámica Fibonacci a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Grafos DFS a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos dfs.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Ordenamiento selección a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento selección.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árboles balanceados AVL/Red-Black a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Estructuras de datos avanzadas Heap en Go. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Árbol de expansión mínima Kruskal a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Diseño de algoritmos paso a paso. Elige un ejemplo simple y muestra estados intermedios. Usa Python si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con diseño de algoritmos paso a paso.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Estructuras de datos avanzadas Heap para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Estructuras de datos avanzadas (Heap, Priority Queue, Deque) a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Contenedores con operaciones garantizadas eficientes.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nProcedimiento:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) por operación en heap\nNotas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Programación dinámica subsecuencia común más larga en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Listas enlazadas, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con listas enlazadas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Análisis de complejidad (Big-O) a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Árboles balanceados (AVL/Red-Black, nociones) en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Ordenamiento quicksort. Elige un ejemplo simple y muestra estados intermedios. Usa Java si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento quicksort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) en C++. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Familia de algoritmos para reordenar elementos según relación de orden.\nMotivación: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nProcedimiento:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nNotas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Backtracking (N-Reinas, permutaciones) a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Explora soluciones incrementales retrocediendo cuando es inválido.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nPasos del algoritmo:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo con traza manual:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Exponencial en general; espacio proporcional a profundidad\nErrores comunes y buenas prácticas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Caminos mínimos Bellman-Ford a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento quicksort, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento quicksort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Elección de estructura de datos adecuada y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Tries (árboles de prefijos), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Algoritmos de cadenas KMP, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas kmp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Depuración de errores debugging, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores debugging.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Árboles balanceados (AVL/Red-Black, nociones), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Dividir y vencer para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con dividir y vencer.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Familia de algoritmos para reordenar elementos según relación de orden.\nMotivación: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nProcedimiento:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nNotas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Programación dinámica Fibonacci para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica fibonacci.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árboles balanceados AVL/Red-Black a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Árbol de expansión mínima Prim. Elige un ejemplo simple y muestra estados intermedios. Usa C si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima prim.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Estructuras de datos avanzadas Heap, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Caminos mínimos Dijkstra a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Caminos mínimos Dijkstra de dificultad intermedio y resuélvelo completamente con ejemplo y código en C.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Backtracking N-Reinas a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking n-reinas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Programación dinámica subsecuencia común más larga de dificultad básico y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento (burbuja, inserción, selección, mergesort, quicksort), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Programación dinámica Fibonacci a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica fibonacci.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Algoritmos de cadenas Rabin-Karp a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Caminos mínimos Dijkstra. Elige un ejemplo simple y muestra estados intermedios. Usa C si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Estructuras de datos avanzadas Priority Queue, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas priority queue.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Árboles balanceados (AVL/Red-Black, nociones). Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Análisis de complejidad (Big-O) para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Depuración de errores (debugging) a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con depuración de errores (debugging).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Greedy (cambio de monedas, interval scheduling) para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Construye solución paso a paso con la mejor decisión local.\nMotivación: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nProcedimiento:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(n log n) con ordenamiento\nNotas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Árbol de expansión mínima Kruskal. Elige un ejemplo simple y muestra estados intermedios. Usa C si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Estructuras de datos avanzadas Priority Queue a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas priority queue.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Tries (árboles de prefijos) a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Diseño de algoritmos paso a paso de dificultad avanzado y resuélvelo completamente con ejemplo y código en Java.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con diseño de algoritmos paso a paso.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Programación dinámica mochila a Python y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica mochila.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Árboles binarios y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles binarios.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Elección de estructura de datos adecuada a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Comparación de enfoques fuerza bruta vs. optimizado a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Python, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Depuración de errores (debugging) a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores (debugging).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Backtracking (N-Reinas, permutaciones) a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Greedy cambio de monedas a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy cambio de monedas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Hashing y tablas hash a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Mapea claves a índices con función hash; maneja colisiones.\nMotivación: Se aplica en problemas relacionados con hashing y tablas hash.\nProcedimiento:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Promedio O(1) por operación\nNotas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Estructuras de datos avanzadas Heap en Go. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Greedy cambio de monedas a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy cambio de monedas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Estructuras de datos avanzadas Deque a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas deque.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Ordenamiento quicksort a JavaScript y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento quicksort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Hashing y tablas hash de dificultad básico y resuélvelo completamente con ejemplo y código en C++.", "response": "Resumen: Mapea claves a índices con función hash; maneja colisiones.\nMotivación: Se aplica en problemas relacionados con hashing y tablas hash.\nProcedimiento:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Promedio O(1) por operación\nNotas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Caminos mínimos Dijkstra a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Búsqueda binaria en Java. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con búsqueda binaria.\nPasos del algoritmo:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo con traza manual:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(log n) tiempo, O(1) espacio\nErrores comunes y buenas prácticas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Ordenamiento inserción de dificultad básico y resuélvelo completamente con ejemplo y código en C.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento inserción.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Hashing y tablas hash para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Mapea claves a índices con función hash; maneja colisiones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con hashing y tablas hash.\nPasos del algoritmo:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo con traza manual:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Promedio O(1) por operación\nErrores comunes y buenas prácticas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento quicksort para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento quicksort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Programación dinámica mochila a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica mochila.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Caminos mínimos Bellman-Ford. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Dividir y vencer en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Estructuras de datos avanzadas (Heap, Priority Queue, Deque) a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Contenedores con operaciones garantizadas eficientes.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nProcedimiento:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) por operación en heap\nNotas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Algoritmos de cadenas KMP. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas kmp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Programación dinámica subsecuencia común más larga. Elige un ejemplo simple y muestra estados intermedios. Usa C si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Elección de estructura de datos adecuada a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Grafos DFS en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos dfs.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Árbol de expansión mínima (Prim, Kruskal) a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Algoritmos de cadenas KMP en Python. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas kmp.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Dividir y vencer y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Grafos DFS. Elige un ejemplo simple y muestra estados intermedios. Usa C si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos dfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Ordenamiento mergesort. Elige un ejemplo simple y muestra estados intermedios. Usa Java si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento mergesort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Análisis de complejidad (Big-O) a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Depuración de errores debugging a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores debugging.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Backtracking (N-Reinas, permutaciones) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento selección para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento selección.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Árboles balanceados nociones a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados nociones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Estructuras de datos avanzadas Heap a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Técnicas lineales/esperadas para matching de patrones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nPasos del algoritmo:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo con traza manual:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: KMP/Z O(n+m); RK promedio O(n+m)\nErrores comunes y buenas prácticas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Hashing y tablas hash a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Go, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Mapea claves a índices con función hash; maneja colisiones.\nMotivación: Se aplica en problemas relacionados con hashing y tablas hash.\nProcedimiento:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Promedio O(1) por operación\nNotas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árboles balanceados nociones para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados nociones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Backtracking permutaciones y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con backtracking permutaciones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árboles balanceados (AVL/Red-Black, nociones) a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Árbol de expansión mínima (Prim, Kruskal) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Caminos mínimos (Dijkstra, Bellman-Ford) para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nMotivación: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nProcedimiento:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nNotas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Greedy (cambio de monedas, interval scheduling) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Construye solución paso a paso con la mejor decisión local.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nPasos del algoritmo:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo con traza manual:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(n log n) con ordenamiento\nErrores comunes y buenas prácticas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Dividir y vencer a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Backtracking (N-Reinas, permutaciones) de dificultad avanzado y resuélvelo completamente con ejemplo y código en Python.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Tries (árboles de prefijos) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Programación dinámica Fibonacci a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Árboles balanceados nociones en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados nociones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árbol de expansión mínima Kruskal para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Árboles balanceados (AVL/Red-Black, nociones), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Pilas y colas en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pilas y colas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Dividir y vencer y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con dividir y vencer.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Estructuras de datos avanzadas Heap a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Estructuras de datos avanzadas Priority Queue a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas priority queue.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Ordenamiento quicksort a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento quicksort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Caminos mínimos Bellman-Ford. Elige un ejemplo simple y muestra estados intermedios. Usa Python si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Programación dinámica (Fibonacci, mochila, subsecuencia común más larga) a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Resuelve subproblemas y almacena resultados para evitar recomputación.\nMotivación: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nProcedimiento:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Típicamente O(n), O(n^2) según problema\nNotas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Greedy (cambio de monedas, interval scheduling) a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Construye solución paso a paso con la mejor decisión local.\nMotivación: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nProcedimiento:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(n log n) con ordenamiento\nNotas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Backtracking permutaciones y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking permutaciones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árboles balanceados AVL/Red-Black a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Estructuras de datos avanzadas (Heap, Priority Queue, Deque) para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Contenedores con operaciones garantizadas eficientes.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nProcedimiento:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) por operación en heap\nNotas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Pseudocódigo a código a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Estructuras de datos avanzadas Priority Queue a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas priority queue.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Programación dinámica subsecuencia común más larga de dificultad básico y resuélvelo completamente con ejemplo y código en C.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento (burbuja, inserción, selección, mergesort, quicksort), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Familia de algoritmos para reordenar elementos según relación de orden.\nMotivación: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nProcedimiento:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nNotas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Programación dinámica subsecuencia común más larga a JavaScript y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Comparación de enfoques fuerza bruta vs. optimizado de dificultad avanzado y resuélvelo completamente con ejemplo y código en Java.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Técnicas lineales/esperadas para matching de patrones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nPasos del algoritmo:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo con traza manual:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: KMP/Z O(n+m); RK promedio O(n+m)\nErrores comunes y buenas prácticas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Ordenamiento inserción y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento inserción.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Backtracking N-Reinas a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con backtracking n-reinas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árbol de expansión mínima Kruskal a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Recursión a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con recursión.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Árboles balanceados (AVL/Red-Black, nociones) a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Greedy interval scheduling en Java. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy interval scheduling.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Programación dinámica Fibonacci para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica fibonacci.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) a nivel avanzado. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Go, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Técnicas lineales/esperadas para matching de patrones.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nProcedimiento:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: KMP/Z O(n+m); RK promedio O(n+m)\nNotas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Depuración de errores (debugging) de dificultad avanzado y resuélvelo completamente con ejemplo y código en Java.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores (debugging).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Depuración de errores (debugging) para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores (debugging).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Pilas y colas, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pilas y colas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Estructuras de datos avanzadas Deque, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas deque.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Estructuras de datos avanzadas Heap y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Comparación de enfoques (fuerza bruta vs. optimizado) a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques (fuerza bruta vs. optimizado).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento inserción, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento inserción.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Algoritmos de cadenas Rabin-Karp en C++. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Tries (árboles de prefijos) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Comparación de enfoques fuerza bruta vs. optimizado en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Árboles balanceados (AVL/Red-Black, nociones), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Comparación de enfoques (fuerza bruta vs. optimizado) en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques (fuerza bruta vs. optimizado).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Tries árboles de prefijos a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries árboles de prefijos.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Árboles balanceados AVL/Red-Black a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Estructuras de datos avanzadas Deque, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas deque.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Ordenamiento mergesort a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento mergesort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Programación dinámica (Fibonacci, mochila, subsecuencia común más larga) a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Resuelve subproblemas y almacena resultados para evitar recomputación.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nPasos del algoritmo:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo con traza manual:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Típicamente O(n), O(n^2) según problema\nErrores comunes y buenas prácticas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Caminos mínimos Dijkstra y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con caminos mínimos dijkstra.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Búsqueda binaria a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nMotivación: Se aplica en problemas relacionados con búsqueda binaria.\nProcedimiento:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) tiempo, O(1) espacio\nNotas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Estructuras de datos avanzadas Priority Queue a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas priority queue.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Árboles binarios en Java. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles binarios.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Búsqueda binaria, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con búsqueda binaria.\nPasos del algoritmo:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo con traza manual:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(log n) tiempo, O(1) espacio\nErrores comunes y buenas prácticas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Algoritmos de cadenas (KMP, Z-function, Rabin-Karp). Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Técnicas lineales/esperadas para matching de patrones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nPasos del algoritmo:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo con traza manual:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: KMP/Z O(n+m); RK promedio O(n+m)\nErrores comunes y buenas prácticas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Caminos mínimos (Dijkstra, Bellman-Ford), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nPasos del algoritmo:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo con traza manual:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nErrores comunes y buenas prácticas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Comparación de enfoques fuerza bruta vs. optimizado de dificultad básico y resuélvelo completamente con ejemplo y código en Java.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Hashing y tablas hash a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Mapea claves a índices con función hash; maneja colisiones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con hashing y tablas hash.\nPasos del algoritmo:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo con traza manual:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Promedio O(1) por operación\nErrores comunes y buenas prácticas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Estructuras de datos avanzadas Heap de dificultad avanzado y resuélvelo completamente con ejemplo y código en Go.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Grafos BFS a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos bfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Pilas y colas y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pilas y colas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Dividir y vencer a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Programación dinámica subsecuencia común más larga para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Programación dinámica subsecuencia común más larga a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Pseudocódigo a código en C. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pseudocódigo a código.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Pseudocódigo a código de dificultad intermedio y resuélvelo completamente con ejemplo y código en Java.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pseudocódigo a código.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Greedy interval scheduling y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy interval scheduling.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Grafos (BFS, DFS) en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Recorridos fundamentales para explorar nodos y aristas.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos (bfs, dfs).\nPasos del algoritmo:\n- BFS con cola por niveles\n- DFS con pila o recursión\nEjemplo con traza manual:\nGrafo en línea A-B-C: BFS distancias 0,1,2.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(V+E) tiempo, O(V) espacio\nErrores comunes y buenas prácticas: No marcar visitados al encolar; recursión profunda en DFS\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento selección para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento selección.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Análisis de complejidad (Big-O) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Pilas y colas de dificultad avanzado y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pilas y colas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Depuración de errores (debugging) a JavaScript y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores (debugging).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Pilas y colas en JavaScript. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pilas y colas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Greedy interval scheduling a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy interval scheduling.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Backtracking (N-Reinas, permutaciones) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Análisis de complejidad Big-O a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con análisis de complejidad big-o.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Árbol de expansión mínima Kruskal. Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Árbol de expansión mínima Prim y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima prim.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árbol de expansión mínima Kruskal a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Ordenamiento burbuja de dificultad avanzado y resuélvelo completamente con ejemplo y código en Go.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento burbuja.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Pseudocódigo a código en Java. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Algoritmos de cadenas KMP a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas kmp.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Greedy cambio de monedas en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy cambio de monedas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Greedy (cambio de monedas, interval scheduling) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Construye solución paso a paso con la mejor decisión local.\nMotivación: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nProcedimiento:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(n log n) con ordenamiento\nNotas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Árboles binarios a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles binarios.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Estructuras de datos avanzadas Priority Queue, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas priority queue.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Técnicas lineales/esperadas para matching de patrones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nPasos del algoritmo:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo con traza manual:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: KMP/Z O(n+m); RK promedio O(n+m)\nErrores comunes y buenas prácticas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Hashing y tablas hash para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Mapea claves a índices con función hash; maneja colisiones.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con hashing y tablas hash.\nPasos del algoritmo:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo con traza manual:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Promedio O(1) por operación\nErrores comunes y buenas prácticas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Diseño de algoritmos paso a paso y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con diseño de algoritmos paso a paso.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Pseudocódigo a código para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árboles binarios para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles binarios.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Caminos mínimos (Dijkstra, Bellman-Ford) para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nMotivación: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nProcedimiento:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nNotas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Recursión. Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con recursión.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento (burbuja, inserción, selección, mergesort, quicksort), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Familia de algoritmos para reordenar elementos según relación de orden.\nMotivación: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nProcedimiento:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nNotas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árboles balanceados nociones para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados nociones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Estructuras de datos avanzadas (Heap, Priority Queue, Deque) para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Contenedores con operaciones garantizadas eficientes.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nProcedimiento:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) por operación en heap\nNotas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Estructuras de datos avanzadas Heap y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Caminos mínimos (Dijkstra, Bellman-Ford). Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Definición/Idea: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nPasos del algoritmo:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo con traza manual:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nErrores comunes y buenas prácticas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Depuración de errores debugging a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores debugging.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Backtracking (N-Reinas, permutaciones), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Explora soluciones incrementales retrocediendo cuando es inválido.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nPasos del algoritmo:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo con traza manual:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Exponencial en general; espacio proporcional a profundidad\nErrores comunes y buenas prácticas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Estructuras de datos avanzadas (Heap, Priority Queue, Deque), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Contenedores con operaciones garantizadas eficientes.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nProcedimiento:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) por operación en heap\nNotas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Hashing y tablas hash a JavaScript y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Mapea claves a índices con función hash; maneja colisiones.\nMotivación: Se aplica en problemas relacionados con hashing y tablas hash.\nProcedimiento:\n- Elegir función\n- Elegir esquema de colisión\n- Rehash al superar factor de carga\nEjemplo:\nChaining: varias claves en mismo bucket; Open addressing: sondeo.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Promedio O(1) por operación\nNotas: No redimensionar; mala función hash\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Dividir y vencer a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Estructuras de datos avanzadas Heap. Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Árbol de expansión mínima Prim, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima prim.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árboles balanceados AVL/Red-Black de dificultad básico y resuélvelo completamente con ejemplo y código en C.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Backtracking (N-Reinas, permutaciones) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Backtracking N-Reinas para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking n-reinas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Pilas y colas para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pilas y colas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Backtracking (N-Reinas, permutaciones) a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Explora soluciones incrementales retrocediendo cuando es inválido.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nPasos del algoritmo:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo con traza manual:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Exponencial en general; espacio proporcional a profundidad\nErrores comunes y buenas prácticas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Greedy interval scheduling a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy interval scheduling.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Caminos mínimos Bellman-Ford a JavaScript y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Backtracking (N-Reinas, permutaciones) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Algoritmos de cadenas Z-function a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Python, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con algoritmos de cadenas z-function.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Comparación de enfoques fuerza bruta vs. optimizado para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Algoritmos de cadenas Z-function para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas z-function.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Recursión, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con recursión.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Dividir y vencer para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Tries (árboles de prefijos), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nMotivación: Se aplica en problemas relacionados con tries (árboles de prefijos).\nProcedimiento:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(L) por operación\nNotas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Programación dinámica subsecuencia común más larga en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento selección para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento selección.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Ordenamiento inserción para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento inserción.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Análisis de complejidad Big-O para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad big-o.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Análisis de complejidad (Big-O) a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Greedy (cambio de monedas, interval scheduling), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Construye solución paso a paso con la mejor decisión local.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy (cambio de monedas, interval scheduling).\nPasos del algoritmo:\n- Definir criterio\n- Ordenar si aplica\n- Seleccionar mientras sea válido\nEjemplo con traza manual:\nInterval scheduling: ordenar por fin y tomar compatibles.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(n log n) con ordenamiento\nErrores comunes y buenas prácticas: Aplicarlo en problemas donde no garantiza optimalidad\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Depuración de errores debugging para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con depuración de errores debugging.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Pilas y colas de dificultad básico y resuélvelo completamente con ejemplo y código en C++.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pilas y colas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Depuración de errores debugging para nivel intermedio. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con depuración de errores debugging.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Backtracking (N-Reinas, permutaciones) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento mergesort, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento mergesort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Backtracking permutaciones y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking permutaciones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Grafos BFS para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos bfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Algoritmos de cadenas (KMP, Z-function, Rabin-Karp) a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Técnicas lineales/esperadas para matching de patrones.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas (kmp, z-function, rabin-karp).\nProcedimiento:\n- KMP: pi (prefijo-sufijo)\n- Z: ventana [l,r]\n- RK: hash rodante\nEjemplo:\nPatrones repetitivos favorecen KMP; Z calcula coincidencias con prefijo.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: KMP/Z O(n+m); RK promedio O(n+m)\nNotas: Errores en pi; colisiones en RK sin verificación\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Pilas y colas en Go. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pilas y colas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Programación dinámica subsecuencia común más larga. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento mergesort, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento mergesort.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Comparación de enfoques (fuerza bruta vs. optimizado) a C y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con comparación de enfoques (fuerza bruta vs. optimizado).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Elección de estructura de datos adecuada en C++. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Depuración de errores debugging y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con depuración de errores debugging.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Pseudocódigo a código. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con pseudocódigo a código.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Programación dinámica (Fibonacci, mochila, subsecuencia común más larga), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Resuelve subproblemas y almacena resultados para evitar recomputación.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica (fibonacci, mochila, subsecuencia común más larga).\nPasos del algoritmo:\n- Definir estado y transición\n- Memoización o tabulación\n- Reconstrucción opcional\nEjemplo con traza manual:\nLCS dp[i][j] = ...; Fibonacci con tabla hasta n.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Típicamente O(n), O(n^2) según problema\nErrores comunes y buenas prácticas: Olvidar casos base; orden de iteración incorrecto\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Dividir y vencer en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árboles balanceados nociones de dificultad avanzado y resuélvelo completamente con ejemplo y código en Python.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados nociones.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Caminos mínimos Bellman-Ford a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Caminos mínimos (Dijkstra, Bellman-Ford) a Go y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nPasos del algoritmo:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo con traza manual:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nErrores comunes y buenas prácticas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árboles balanceados (AVL/Red-Black, nociones) para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento inserción, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento inserción.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Búsqueda binaria a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Divide el rango a la mitad para localizar un objetivo en datos ordenados.\nMotivación: Se aplica en problemas relacionados con búsqueda binaria.\nProcedimiento:\n- Inicializar low/high\n- Calcular mid\n- Comparar y mover límites\nEjemplo:\nBuscar 7 en [1,3,5,7,9]: low=0, high=4, mid=2→5<7, low=3; mid=3→7 hallado.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) tiempo, O(1) espacio\nNotas: Errores off-by-one; condición de bucle incorrecta; overflow al calcular mid\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Greedy cambio de monedas, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy cambio de monedas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Programación dinámica subsecuencia común más larga a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Programación dinámica mochila a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con programación dinámica mochila.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Caminos mínimos (Dijkstra, Bellman-Ford) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nPasos del algoritmo:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo con traza manual:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nErrores comunes y buenas prácticas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Árboles balanceados AVL/Red-Black, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Árboles balanceados (AVL/Red-Black, nociones). Elige un ejemplo simple y muestra estados intermedios. Usa C si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados (avl/red-black, nociones).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Backtracking N-Reinas en Java. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking n-reinas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Elección de estructura de datos adecuada. Elige un ejemplo simple y muestra estados intermedios. Usa Python si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Árbol de expansión mínima Kruskal en Java. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Greedy cambio de monedas a nivel básico: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con greedy cambio de monedas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Tries (árboles de prefijos), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Árbol que almacena prefijos para búsquedas rápidas por carácter.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries (árboles de prefijos).\nPasos del algoritmo:\n- Insertar recorriendo caracteres\n- Buscar prefijo\n- Señalar fin de palabra\nEjemplo con traza manual:\nInsert 'car','cat'; prefijo 'ca' válido.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(L) por operación\nErrores comunes y buenas prácticas: No marcar fin; alto uso de memoria\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Listas enlazadas y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con listas enlazadas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Programación dinámica Fibonacci en Java. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Programación dinámica Fibonacci. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Ordenamiento selección. Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento selección.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Programación dinámica Fibonacci. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Comparación de enfoques fuerza bruta vs. optimizado, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con comparación de enfoques fuerza bruta vs. optimizado.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Grafos DFS. Elige un ejemplo simple y muestra estados intermedios. Usa Java si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos dfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Elección de estructura de datos adecuada de dificultad intermedio y resuélvelo completamente con ejemplo y código en Python.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árbol de expansión mínima Kruskal para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima kruskal.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Ordenamiento burbuja de dificultad avanzado y resuélvelo completamente con ejemplo y código en Go.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento burbuja.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Estructuras de datos avanzadas Heap a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con estructuras de datos avanzadas heap.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árbol de expansión mínima (Prim, Kruskal) de dificultad intermedio y resuélvelo completamente con ejemplo y código en Go.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Elección de estructura de datos adecuada a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con elección de estructura de datos adecuada.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Grafos DFS a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos dfs.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Caminos mínimos (Dijkstra, Bellman-Ford) para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Cálculo de coste mínimo desde un origen con restricciones de pesos.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos (dijkstra, bellman-ford).\nPasos del algoritmo:\n- Dijkstra: cola de prioridad, pesos no negativos\n- Bellman-Ford: relajaciones repetidas\nEjemplo con traza manual:\nA→B(1), A→C(4), B→C(2): dist(C)=3 vía B con Dijkstra.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Dijkstra O((V+E) log V), Bellman-Ford O(VE)\nErrores comunes y buenas prácticas: Usar Dijkstra con pesos negativos; no detectar ciclos negativos\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Tries árboles de prefijos en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con tries árboles de prefijos.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Ordenamiento inserción. Elige un ejemplo simple y muestra estados intermedios. Usa Python si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento inserción.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Algoritmos de cadenas Rabin-Karp para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Ordenamiento selección a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en JavaScript, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento selección.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árbol de expansión mínima (Prim, Kruskal) de dificultad intermedio y resuélvelo completamente con ejemplo y código en JavaScript.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Árbol de expansión mínima Prim para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima prim.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Árboles balanceados AVL/Red-Black a nivel básico. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) en C. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Familia de algoritmos para reordenar elementos según relación de orden.\nMotivación: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nProcedimiento:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nNotas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Ordenamiento inserción, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento inserción.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árboles balanceados AVL/Red-Black de dificultad básico y resuélvelo completamente con ejemplo y código en Go.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Grafos (BFS, DFS) de dificultad básico y resuélvelo completamente con ejemplo y código en Go.", "response": "Definición/Idea: Recorridos fundamentales para explorar nodos y aristas.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con grafos (bfs, dfs).\nPasos del algoritmo:\n- BFS con cola por niveles\n- DFS con pila o recursión\nEjemplo con traza manual:\nGrafo en línea A-B-C: BFS distancias 0,1,2.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: O(V+E) tiempo, O(V) espacio\nErrores comunes y buenas prácticas: No marcar visitados al encolar; recursión profunda en DFS\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Análisis de complejidad Big-O para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad big-o.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento mergesort en C. Proporciona versión corregida y justifica los cambios.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento mergesort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Árboles balanceados AVL/Red-Black en Go. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Análisis de complejidad (Big-O), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Ordenamiento quicksort de dificultad básico y resuélvelo completamente con ejemplo y código en C++.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con ordenamiento quicksort.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Árbol de expansión mínima (Prim, Kruskal) a C++ y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Ordenamiento burbuja a nivel intermedio: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento burbuja.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Pseudocódigo a código. Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Listas enlazadas para nivel avanzado. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con listas enlazadas.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Ordenamiento (burbuja, inserción, selección, mergesort, quicksort) en C. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Familia de algoritmos para reordenar elementos según relación de orden.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con ordenamiento (burbuja, inserción, selección, mergesort, quicksort).\nPasos del algoritmo:\n- Burbuja: comparar adyacentes\n- Inserción: insertar en sublista ordenada\n- Selección: escoger mínimo\n- Merge: dividir y mezclar\n- Quick: particionar por pivote\nEjemplo con traza manual:\nEjemplo breve: [3,1,2] → tras inserción: [1,2,3]\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Burbuja/Inserción/Selección O(n^2), Merge/Quick promedio O(n log n)\nErrores comunes y buenas prácticas: Pivote mal elegido en Quick; índices incorrectos en Merge\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Dividir y vencer a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Go, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con dividir y vencer.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Grafos BFS. Elige un ejemplo simple y muestra estados intermedios. Usa JavaScript si aplica.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con grafos bfs.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Pilas y colas a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en C++, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pilas y colas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Programación dinámica Fibonacci, explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica fibonacci.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Caminos mínimos Bellman-Ford de dificultad avanzado y resuélvelo completamente con ejemplo y código en C++.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Backtracking permutaciones de dificultad básico y resuélvelo completamente con ejemplo y código en Python.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con backtracking permutaciones.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Backtracking N-Reinas de dificultad avanzado y resuélvelo completamente con ejemplo y código en C.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con backtracking n-reinas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Árboles balanceados AVL/Red-Black a Python y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árboles balanceados avl/red-black.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Convierte el siguiente pseudocódigo relacionado con Programación dinámica mochila a Java y explica cada parte:\n1) Leer entrada\n2) Procesar\n3) Devolver resultado", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica mochila.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Caminos mínimos Bellman-Ford a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con caminos mínimos bellman-ford.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Explica Pseudocódigo a código a nivel intermedio. Incluye: idea, cuándo usarlo, pasos del algoritmo, un ejemplo breve en Java, complejidad temporal y espacial, y errores comunes.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con pseudocódigo a código.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Analiza la complejidad temporal y espacial de Algoritmos de cadenas Rabin-Karp para nivel básico. Indica casos mejor/promedio/peor si corresponde.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas rabin-karp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en JavaScript: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Árbol de expansión mínima (Prim, Kruskal) en C++. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con árbol de expansión mínima (prim, kruskal).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Guía el diseño paso a paso de un algoritmo para Análisis de complejidad (Big-O), explicando decisiones e invariantes si aplica. Incluye posibilidades de optimización.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con análisis de complejidad (big-o).\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Go: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Algoritmos de cadenas KMP y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con algoritmos de cadenas kmp.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Corrige y explica errores típicos en un fragmento relacionado con Greedy cambio de monedas en Python. Proporciona versión corregida y justifica los cambios.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con greedy cambio de monedas.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Realiza una traza paso a paso de Backtracking (N-Reinas, permutaciones). Elige un ejemplo simple y muestra estados intermedios. Usa C++ si aplica.", "response": "Resumen: Explora soluciones incrementales retrocediendo cuando es inválido.\nMotivación: Se aplica en problemas relacionados con backtracking (n-reinas, permutaciones).\nProcedimiento:\n- Probar opción\n- Validar\n- Recurre/retrocede\nEjemplo:\nN=4: soluciones (1,3,0,2) y (2,0,3,1).\nEjemplo en C++: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Exponencial en general; espacio proporcional a profundidad\nNotas: No deshacer marcas; poda insuficiente\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Árbol de expansión mínima Prim de dificultad básico y resuélvelo completamente con ejemplo y código en Java.", "response": "Resumen: Concepto clave de algoritmia que requiere estructura y claridad.\nMotivación: Se aplica en problemas relacionados con árbol de expansión mínima prim.\nProcedimiento:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Java: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: Depende del algoritmo; indica tiempo y espacio\nNotas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Compara dos enfoques para Programación dinámica subsecuencia común más larga a nivel avanzado: uno simple y otro optimizado. Explica ventajas/desventajas y complejidades.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica subsecuencia común más larga.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Elige una estructura de datos adecuada para Programación dinámica mochila y justifica la decisión. Menciona alternativas y casos donde cambiaría la elección.", "response": "Definición/Idea: Concepto clave de algoritmia que requiere estructura y claridad.\nCuándo usarlo y por qué: Se aplica en problemas relacionados con programación dinámica mochila.\nPasos del algoritmo:\n- Describir pasos cuidadosamente\n- Aclarar precondiciones\n- Validar postcondiciones\nEjemplo con traza manual:\nPequeño ejemplo con entradas reducidas para trazar manualmente.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nComplejidad temporal y espacial: Depende del algoritmo; indica tiempo y espacio\nErrores comunes y buenas prácticas: Errores de índices y no considerar casos borde\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
{"prompt": "Plantea un ejercicio sobre Estructuras de datos avanzadas (Heap, Priority Queue, Deque) de dificultad básico y resuélvelo completamente con ejemplo y código en Python.", "response": "Resumen: Contenedores con operaciones garantizadas eficientes.\nMotivación: Se aplica en problemas relacionados con estructuras de datos avanzadas (heap, priority queue, deque).\nProcedimiento:\n- Heap: push/pop log n\n- Deque: doble extremo\n- PQ: extraer min/max\nEjemplo:\nInsert 5,3,4 → raíz 3; pop devuelve 3.\nEjemplo en Python: describir brevemente en pseudocódigo/código.\nAnálisis de complejidad: O(log n) por operación en heap\nNotas: No mantener invariantes; índices en heapify\nRecomendación pedagógica: estructura la explicación con ejemplos pequeños antes de generalizar."}
